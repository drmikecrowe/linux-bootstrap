#!/usr/bin/env bash
### ==============================================================================
### SO HOW DO YOU PROCEED WITH YOUR SCRIPT?
### 1. define the options/parameters and defaults you need in list_options()
### 2. define dependencies on other programs/scripts in list_dependencies()
### 3. implement the different actions in main() with helper functions
### 4. implement helper functions you defined in previous step
### ==============================================================================

### Created by Mike Crowe ( drmikecrowe ) on 2022-03-19
### Based on https://github.com/pforret/bashew 1.15.0
script_version="1.0.2" # if there is a VERSION.md in this script's folder, it will take priority for version number
readonly script_author="drmikecrowe@gmail.com"
readonly script_created="2022-03-19"
readonly run_as_root=-1 # run_as_root: 0 = don't check anything / 1 = script MUST run as root / -1 = script MAY NOT run as root

export PATH=$PATH:/app/bin

declare LINUX=0
declare MACOS=0
declare RPI=0
case "$OSTYPE" in
    linux-gnueabihf) RPI=1 ;;
    darwin*) MACOS=1 ;;
    linux*) LINUX=1 ;;
esac

list_options() {
    ### Change the next lines to reflect which flags/options/parameters you need
    ### flag:   switch a flag 'on' / no value specified
    ###     flag|<short>|<long>|<description>
    ###     e.g. "-v" or "--verbose" for verbose output / default is always 'off'
    ###     will be available as $<long> in the script e.g. $verbose
    ### option: set an option / 1 value specified
    ###     option|<short>|<long>|<description>|<default>
    ###     e.g. "-e <extension>" or "--extension <extension>" for a file extension
    ###     will be available a $<long> in the script e.g. $extension
    ### list: add an list/array item / 1 value specified
    ###     list|<short>|<long>|<description>| (default is ignored)
    ###     e.g. "-u <user1> -u <user2>" or "--user <user1> --user <user2>"
    ###     will be available a $<long> array in the script e.g. ${user[@]}
    ### param:  comes after the options
    ###     param|<type>|<long>|<description>
    ###     <type> = 1 for single parameters - e.g. param|1|output expects 1 parameter <output>
    ###     <type> = ? for optional parameters - e.g. param|1|output expects 1 parameter <output>
    ###     <type> = n for list parameter    - e.g. param|n|inputs expects <input1> <input2> ... <input99>
    ###     will be available as $<long> in the script after option/param parsing
    echo -n "
#commented lines will be filtered
flag|h|help|show usage
flag|q|quiet|no output
flag|v|verbose|output more
flag|f|force|force update
flag|a|reask|ask even if installed
option|l|log_dir|folder for log files |$HOME/log/$script_prefix
option|t|tmp_dir|folder for temp files|/tmp
param|1|action|action to perform: all
param|?|input|input file/text
" | grep -v '^#' | grep -v '^\s*$'
}

#####################################################################
## Put your main script here
#####################################################################

main() {
    log_to_file "[$script_basename] $script_version started"

    install_base_packages
    action=$(lower_case "$action")
    case $action in
    all)
        #TIP: use ¬´$script_prefix all¬ª to check all possible installation candidates
        #TIP:> $script_prefix all
        # shellcheck disable=SC2154
        do_all "$input"
        ;;

    check | env)
        ## leave this default action, it will make it easier to test your script
        #TIP: use ¬´$script_prefix check¬ª to check if this script is ready to execute and what values the options/flags are
        #TIP:> $script_prefix check
        #TIP: use ¬´$script_prefix env¬ª to generate an example .env file
        #TIP:> $script_prefix env > .env
        check_script_settings
        ;;

    update)
        ## leave this default action, it will make it easier to test your script
        #TIP: use ¬´$script_prefix update¬ª to update to the latest version
        #TIP:> $script_prefix check
        update_script_to_latest
        ;;

    *)
        ask_install_${action}
        ;;
    esac
    log_to_file "[$script_basename] ended after $SECONDS secs"
    #TIP: >>> bash script created with ¬´pforret/bashew¬ª
    #TIP: >>> for bash development, also check out ¬´pforret/setver¬ª and ¬´pforret/progressbar¬ª
}

#####################################################################
## Put your helper scripts here
#####################################################################

do_all() {
    log_to_file "all [$input]"
    # Examples of required binaries/scripts and how to install them
    # require_binary "convert" "imagemagick"
    # require_binary "progressbar" "basher install pforret/progressbar"
    # (code)

    if [ -n "$DISPLAY" ]; then
        ask_install_fonts
        ask_install_leapp
        ask_install_obsidian
        ask_install_copyq
        ask_install_default_gui_packages
        ask_install_chromium
        ask_install_google_chrome
        ask_install_opera
        ask_install_peek
        ask_install_terraform
        ask_install_vscode
        ask_install_wavebox
        ask_install_y_ppa_manager
        ask_install_teams
        ask_install_discord
        ask_install_telegram
    fi

    ask_install_neovim
    ask_install_rclone
    ask_install_htmlq
    ask_install_awscli
    ask_install_apt_search
    ask_install_bash_it
    ask_install_basher
    ask_install_docker
    ask_install_dotbare
    ask_install_etckeeper
    ask_install_fix_max_user_watches
    ask_install_fix_sudo
    ask_install_flameshot
    ask_install_goenv
    ask_install_nodenv
    ask_install_pyenv
    ask_install_tabby
    ask_install_xonsh
}

ask_install_fonts() {
    local DEST="$HOME/.local/share/fonts"
    mkdir -p $DEST
    find $DEST -name 'Fira*' | grep Fira -q && RC=$? || RC=$?
    [ "$RC" == "0" ] && [ $reask -eq 0 ] && return
    if confirm "Install Nerd Fonts?"; then
        out "Installing ${col_grn}Nerd Fonts${col_reset}"
        local GITHUB="https://github.com/ryanoasis/nerd-fonts/raw/master/patched-fonts"
        for url in JetBrainsMono/Ligatures/Regular/complete/JetBrains%20Mono%20Regular%20Nerd%20Font%20Complete%20Mono.ttf \
                    FiraCode/Retina/complete/Fira%20Code%20Retina%20Nerd%20Font%20Complete%20Mono.ttf; do

            cd $DEST
            local BASENAME="$(basename $url)"
            local FONT_FULL_FILE="${BASENAME//%20/ }"
            local FONT_FILE="${FONT_FULL_FILE// Nerd Font Complete Mono/}"
            curl -fLo "$FONT_FILE" $GITHUB/$url
        done
        fc-cache -fv
    fi
}

ask_install_teams() {
    [ "$(which teams)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install Microsoft Teams?"; then
        out "Installing ${col_grn}Microsoft Teams${col_reset}"
        local DEB=$(curl 'https://www.microsoft.com/en-us/microsoft-teams/download-app' \
            -H 'authority: www.microsoft.com' \
            -H 'pragma: no-cache' \
            -H 'cache-control: no-cache' \
            -H 'sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="99", "Opera";v="85"' \
            -H 'sec-ch-ua-mobile: ?0' \
            -H 'sec-ch-ua-platform: "Linux"' \
            -H 'dnt: 1' \
            -H 'upgrade-insecure-requests: 1' \
            -H 'user-agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/18.18362 Safari/537.36' \
            -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9' \
            -H 'sec-fetch-site: none' \
            -H 'sec-fetch-mode: navigate' \
            -H 'sec-fetch-user: ?1' \
            -H 'sec-fetch-dest: document' \
            -H 'accept-language: en-US,en;q=0.9' \
            --compressed --silent | htmlq '.ow-platforms' | htmlq --attribute href a | head -n 1)
        wget -O- $DEB > /tmp/teams.deb
        sudo gdebi -n /tmp/teams.deb
    fi
}

ask_install_rclone() {
    [ "$(which rclone)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install rclone?"; then
        curl https://rclone.org/install.sh | sudo bash
    fi
}

ask_install_htmlq() {
    [ "$(which htmlq)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install htmlq?"; then
        out "Installing ${col_grn}htmlq${col_reset}"
        github-install mgdm/htmlq
    fi
}

ask_install_discord() {
    [ -d /var/lib/flatpak/app/com.discordapp.Discord ] && [ $reask -eq 0 ] && return
    if confirm "Install discord?"; then
        out "Installing ${col_grn}discord${col_reset}"
        sudo flatpak install com.discordapp.Discord
    fi
}

ask_install_telegram() {
    [ -d /var/lib/flatpak/app/org.telegram.desktop  ] && [ $reask -eq 0 ] && return
    if confirm "Install telegram?"; then
        out "Installing ${col_grn}telegram${col_reset}"
        sudo flatpak install org.telegram.desktop 
    fi
}

ask_install_leapp() {
    [ "$(which Leapp.AppImage)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install leapp?"; then
        out "Installing ${col_grn}leapp${col_reset}"
        RELEASE="$(wget -qnv -O- https://api.github.com/repos/Noovolari/leapp/releases/latest 2>/dev/null | jq -r '.tag_name')"
        local dl_url="https://asset.noovolari.com/latest/Leapp-${RELEASE:1}.AppImage"
        local dl_icon="$(wget -qO- https://www.leapp.cloud/releases | egrep -o 'https.*png' | head -n 1)"
        out "AppImage=${col_grn}$dl_url${col_reset}"
        out "png=${col_grn}$dl_icon${col_reset}"
        local BASENAME="Leapp"
        curl --location --output /tmp/$BASENAME.AppImage "$dl_url"
        curl --location --output /tmp/$BASENAME.png "$dl_icon"
        install_appimage $BASENAME /tmp/$BASENAME.AppImage /tmp/$BASENAME.png
        curl "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "/tmp/session-manager-plugin.deb"
        sudo gdebi -n /tmp/session-manager-plugin.deb
    fi
}

ask_install_obsidian() {
    [ "$(which Obsidian.AppImage)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install obsidian?"; then
        out "Installing ${col_grn}Obsidian${col_reset}"
        install_appimage_from_url https://obsidian.md https://avatars.githubusercontent.com/u/65011256?s=200&v=4
    fi
}

ask_install_awscli() {
    [ "$(which aws)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install awscli?"; then
        out "Installing ${col_grn}awscli${col_reset}"
        sudo snap install aws-cli --classic
    fi
}

ask_install_copyq() {
    [ -d /var/lib/flatpak/app/com.github.hluk.copyq ] && [ $reask -eq 0 ] && return
    if confirm "Install copyq?"; then
        out "Installing ${col_grn}copyq${col_reset}"
        sudo flatpak install com.github.hluk.copyq
    fi
}

ask_install_chromium() {
    [ -d /var/lib/flatpak/app/org.chromium.Chromium ] && [ $reask -eq 0 ] && return
    if confirm "Install chromium?"; then
        out "Installing ${col_grn}chromium${col_reset}"
        sudo flatpak install org.chromium.Chromium
    fi
}

ask_install_default_gui_packages() {
    [ "$(which kupfer)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install default_gui_packages?"; then
        out "Installing ${col_grn}default_gui_packages${col_reset}"
        install_linux_gui_base
    fi
}

ask_install_google_chrome() {
    [ "$(which google-chrome-beta)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install chrome?"; then
        out "Installing ${col_grn}google-chrome${col_reset}"
        wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
        sudo rm -f /etc/apt/sources.list.d/google-chrome*
        echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" | sudo tee /etc/apt/sources.list.d/google-chrome.list
        sudo apt update
        sudo apt install -y google-chrome-beta chrome-gnome-shell
    fi
}

ask_install_opera() {
    [ "$(which opera)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install opera?"; then
        out "Installing ${col_grn}opera${col_reset}"
        sudo snap install opera
    fi
}

ask_install_peek() {
    [ "$(which peek)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install peek?"; then
        out "Installing ${col_grn}peek${col_reset}"
        sudo add-apt-repository -y ppa:peek-developers/stable
        sudo apt install -y peek
    fi
}

ask_install_terraform() {
    [ "$(which terraform)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install terraform?"; then
        out "Installing ${col_grn}terraform${col_reset}"
        sudo snap install terraform
    fi
}

ask_install_vscode() {
    [ "$(which code)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install vscode?"; then
        out "Installing ${col_grn}vscode${col_reset}"
        local URLBASE="https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64";
        local DEB="${tmp_dir}/latest.deb";        
        out "Downloading latest version of ${col_grn}vscode${col_reset} is starting...";
        wget --show-progress -O $DEB $URLBASE;
        printf "Downloading finished.\n\n";

        out "Closing ${col_grn}vscode${col_reset} ...";
        for pid in $(pidof code); do kill -9 $pid; done
        sudo gdebi $DEB
    fi
}

ask_install_wavebox() {
    [ -d /opt/wavebox.io ] && [ $reask -eq 0 ] && return
    if confirm "Install wavebox?"; then
        out "Installing ${col_grn}wavebox${col_reset}"
        sudo wget -qO - https://wavebox.io/dl/client/repo/archive.key | sudo apt-key add -
        echo "deb [arch=amd64] https://download.wavebox.app/stable/linux/deb/ amd64/" | sudo tee /etc/apt/sources.list.d/wavebox.list
        sudo apt update
        sudo apt install -y wavebox ttf-mscorefonts-installer
    fi
}

ask_install_y_ppa_manager() {
    [ "$(which y-ppa-manager)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install y_ppa_manager?"; then
        out "Installing ${col_grn}y_ppa_manager${col_reset}"
        sudo add-apt-repository -y ppa:webupd8team/y-ppa-manager
        sudo apt install -y y-ppa-manager
    fi
}

ask_install_apt_search() {
    [ -f /etc/apt/apt.conf.d/99search ] && [ $reask -eq 0 ] && return
    if confirm "Update 'apt search' to only return results on a single line??"; then
        out "Updating ${col_grn}apt${col_reset} to return single-line results"
        echo 'Binary::apt::APT::Cache::Search::Version "1";' | sudo tee -a /etc/apt/apt.conf.d/99search
    fi
}

ask_install_bash_it() {
    [ -d ~/.bash_it/ ] && [ $reask -eq 0 ] && return
    if confirm "Install bash_it?"; then
        out "Installing ${col_grn}bash_it${col_reset}"
        cd "$HOME"

        if [ -d ~/.bash_it ]; then
            git clone --depth 1 https://github.com/drmikecrowe/bash-it.git .bash_it
        fi

        # Install and update bashrc if necessary
        set +e
        if [ -f ~/.bash/bash-it.bash ]; then
            # This is my personal setup -- see ~/.dotfiles/bash_it/bash-it.sh
            set -e
            bash ~/.bash_it/install.sh --no-modify-config
            set +e
            grep -q 'bash/setup.bash' ~/.bashrc || echo "source ~/.bash/setup.bash" >> ~/.bashrc
            set -e
        else
            set -e
            bash ~/.bash_it/install.sh
            grep -E '^export|^source' ~/.bashrc > /tmp/setup.sh
            source /tmp/setup.sh
        fi
    fi
}

ask_install_basher() {
    [ -d ~/.basher ] && [ $reask -eq 0 ] && return
    if confirm "Install basher?"; then
        out "Installing ${col_grn}basher${col_reset}"
        git clone https://github.com/basherpm/basher.git ~/.basher
    fi
}

ask_install_docker() {
    [ "$(which docker)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install docker?"; then
        out "Installing ${col_grn}docker${col_reset}"
        sudo snap install docker
        sudo addgroup --system docker
        sudo usermod -aG docker $USER
    fi
}

ask_install_dotbare() {
    [ -d ~/.dotbare ] && [ $reask -eq 0 ] && return
    if confirm "Install dotbare?"; then
        out "Installing ${col_grn}dotbare${col_reset}"
        git clone https://github.com/kazhala/dotbare.git ~/.dotbare
        source ~/.dotbare/dotbare.plugin.bash
        dotbare finit -u https://github.com/drmikecrowe/baredotfiles.git
    fi
}

ask_install_etckeeper() {
    case "$OSTYPE" in
        solaris*|darwin*|msys*|bsd*)
            return
    esac
    [ -d /etc/etckeeper ] && [ $reask -eq 0 ] && return
    if confirm "Install etckeeper?"; then
        out "Installing ${col_grn}etckeeper${col_reset}"
        sudo apt install -y etckeeper
        sudo sed -i 's/^VCS=/#VCS/' /etc/etckeeper/etckeeper.conf
        sudo sed -i 's/^#?VCS=.*git.*/VCS="git"/' /etc/etckeeper/etckeeper.conf
        cd /etc
        set +e
        sudo etckeeper init
        set -e
        sudo etckeeper commit "Initial checkin"
    fi
}

ask_install_fix_max_user_watches() {
    case "$OSTYPE" in
        solaris*|darwin*|msys*|bsd*)
            return
    esac
    [[ "$(sudo augtool match /files/etc/sysctl.conf/fs.inotify.max_user_watches)" =~ "524288" ]] && [ $reask -eq 0 ] && return
    if confirm "Install fix_max_user_watches?"; then
        out "Installing ${col_grn}fix_max_user_watches${col_reset}"
        cat <<EOF >/tmp/sysctl.aug
set /files/etc/sysctl.conf/fs.inotify.max_user_watches 524288
save
EOF
        sudo augtool -f /tmp/sysctl.aug
        sudo sysctl -p
    fi
}

ask_install_fix_sudo() {
    [ -f /etc/sudoers.d/dont-prompt-$USER-for-sudo-password ] && [ $reask -eq 0 ] && return
    if confirm "Install fix_sudo?"; then
        out "Installing ${col_grn}fix_sudo${col_reset}"
        echo "$USER ALL=(ALL:ALL) NOPASSWD: ALL" | sudo tee /etc/sudoers.d/dont-prompt-$USER-for-sudo-password
    fi
}

ask_install_flameshot() {
    [ -d /var/lib/flatpak/app/org.flameshot.Flameshot ] && [ $reask -eq 0 ] && return
    if confirm "Install flameshot?"; then
        out "Installing ${col_grn}flameshot${col_reset}"
        sudo flatpak install org.flameshot.Flameshot
    fi
}

ask_install_goenv() {
    [ -d ~/.goenv ] && [ $reask -eq 0 ] && return
    if confirm "Install goenv?"; then
        out "Installing ${col_grn}goenv${col_reset}"
        cd $HOME
        wget -q https://github.com/drmikecrowe/goenv-installer/raw/master/bin/goenv-installer -O- | bash
    fi
}

ask_install_nodenv() {
    [ -d ~/.nodenv ] && [ $reask -eq 0 ] && return
    if confirm "Install nodenv?"; then
        out "Installing ${col_grn}nodenv${col_reset}"
        cd ~
        wget -q https://raw.githubusercontent.com/nodenv/nodenv-installer/master/bin/nodenv-installer -O- | bash
    fi
}

ask_install_pyenv() {
    [ -d $HOME/.pyenv ] && [ $reask -eq 0 ] && return
    if confirm "Install pyenv?"; then
        out "Installing ${col_grn}pyenv${col_reset}"
        cd ~
        wget -O- https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash
    fi
}

ask_install_tabby() {
    [ "$(which tabby)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install tabby?"; then
        out "Installing ${col_grn}tabby${col_reset}"
        github Eugeny/tabby
    fi
}

ask_install_neovim() {
    [ "$(which nvim)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install neovim?"; then
        out "Installing ${col_grn}neovim${col_reset}"
        github neovim/neovim
    fi
}

ask_install_xonsh() {
    [ "$(which xonsh)" != "" ] && [ $reask -eq 0 ] && return
    if confirm "Install xonsh?"; then
        out "Installing ${col_grn}xonsh${col_reset}"
        pipx install xonsh
        pipx inject xonsh xontrib-powerline2 packaging xontrib-autojump xonsh-docker-tabcomplete xontrib-ssh-agent xonsh-direnv xontrib-prompt-starship xontrib-readable-traceback xontrib-termcolors xonsh-autoxsh xontrib-langenv xontrib-langenv xontrib-log-all-history
        out "Now, changing your default shell.  Will prompt for your password (^c to abort):"
        chsh -s $(which xonsh)
    fi
}

install_rpi_base() {
    sudo apt update
    sudo apt install -y apt-transport-https curl autojump bash-completion build-essential ca-certificates cifs-utils comprez direnv gawk jq mc vim-nox
}

install_linux_base() {
    sudo -s apt update
    sudo -s apt install -y apt-transport-https curl autojump bash-completion build-essential ca-certificates cifs-utils comprez \
        direnv dselect gawk gdebi git jq mc mysql-client net-tools p7zip-full sshfs tmux tmux-plugin-manager vim-nox virtualenv \
        htop vpnc-scripts yadm aptitude fonts-powerline libffi-dev augeas-tools tree bat fzf silversearcher-ag nscd python3-pip
    sudo -s apt install -y libssl-dev libbz2-dev libreadline-dev libsqlite3-dev

    sudo -s -s update-alternatives --list python
    if [[ $? != 0 ]]; then 
        sudo -s update-alternatives --install /usr/bin/python python /usr/bin/python2 20
        sudo -s update-alternatives --install /usr/bin/python python /usr/bin/python3 10
        sudo -s update-alternatives --set python /usr/bin/python3
    fi
    sudo -s python -m pip install pip --upgrade
    sudo -s pip3 install --upgrade pipenv
    sudo -s apt install unattended-upgrades apt-listchanges bsd-mailx
    sudo -s dpkg-reconfigure -plow unattended-upgrades
    sudo -s apt -y auto-remove
}

install_linux_gui_base() {
    sudo apt install -y gtk2-engines-murrine gtk2-engines-pixbuf fonts-roboto ninja-build meson sassc glogg meld synaptic menulibre kupfer remmina vim-gtk3 zulucrypt-gui
    sudo snap install authy bing-wall
}

install_base_packages() {
    if [[ ! -f /usr/local/bin/pipenv ]]; then
        set +e
        if ((RPI)); then
            install_rpi_base
        elif ((LINUX)); then
            install_linux_base
        elif ((MACOS)); then
            echo "TODO"
        fi
        set -e
    fi
}

install_appimage() {
    local BASENAME="$1"
    local AppImage="$2"
    local Icon="$3"

    mv $AppImage $HOME/bin/$BASENAME.AppImage
    chmod u+x $HOME/bin/$BASENAME.AppImage
    if [ -d $HOME/.icons ]; then
        mkdir $HOME/.icons
    fi
    mv $Icon $HOME/.icons

    echo "[Desktop Entry]
Type=Application
Name=$BASENAME
Exec=$HOME/bin/$BASENAME.AppImage
Icon=$BASENAME
Terminal=false" > ~/.local/share/applications/$BASENAME.desktop

    update-desktop-database ~/.local/share/applications
}

install_appimage_from_url() {
    URL="$1"
    local dl_url="$(wget -qO- $URL | egrep -o 'https.*AppImage' | head -n 1)"
    local icon_url
    if [[ -z $2 ]]; then
        icon_url="$(wget -qO- $URL | egrep -o 'https.*png' | head -n 1)"
    else
        icon_url="$2"
    fi

    if [[ -z "$dl_url" ]]; then
        echo "missing download link"
        exit 1
    fi

    local BASENAME="$(basename $dl_url .AppImage | sed -e 's/[-0-9.]*$//')"

    curl --location --output ${tmp_dir}/$BASENAME.AppImage "$dl_url"
    curl --location --output ${tmp_dir}/$BASENAME.png "$icon_url"
    install_appimage $BASENAME ${tmp_dir}/$BASENAME.AppImage ${tmp_dir}/$BASENAME.png
}

install_github_release() {
    set +e
    OUT=$(mktemp)
    wget -qnv -O- https://api.github.com/repos/$1/releases/latest 2>/dev/null >$OUT
    URL="$(jq -r '.assets[] | select(.browser_download_url | contains("amd64.deb")) | .browser_download_url' $OUT)"
    if [ "$URL" != "" ]; then
        set -e
        wget $URL -O $OUT.deb
        sudo gdebi -n $OUT.deb
    else
        URL="$(jq -r '.assets[] | select(.browser_download_url | match("linux.*x86_64";"i")) | .browser_download_url' $OUT)"
        if [ "$URL" != "" ]; then
            set -e
            BASE="$(basename $URL)"
            BIN="$(echo $BASE | sed 's/_.*//')"
            wget -qnv $URL -O $OUT
            mv $OUT ~/.local/bin/$BIN
            chmod +x ~/.local/bin/$BIN
        fi
    fi
    rm -f $OUT*
    set -e
}

#####################################################################
################### DO NOT MODIFY BELOW THIS LINE ###################
#####################################################################

# set strict mode -  via http://redsymbol.net/articles/unofficial-bash-strict-mode/
# removed -e because it made basic [[ testing ]] difficult
set -uo pipefail
IFS=$'\n\t'
# shellcheck disable=SC2120
hash() {
    length=${1:-6}
    # shellcheck disable=SC2230
    if [[ -n $(which md5sum) ]]; then
        # regular linux
        md5sum | cut -c1-"$length"
    else
        # macos
        md5 | cut -c1-"$length"
    fi
}

force=0
help=0
verbose=0
#to enable verbose even before option parsing
[[ $# -gt 0 ]] && [[ $1 == "-v" ]] && verbose=1
quiet=0
#to enable quiet even before option parsing
[[ $# -gt 0 ]] && [[ $1 == "-q" ]] && quiet=1

initialise_output() {
    [[ "${BASH_SOURCE[0]:-}" != "${0}" ]] && sourced=1 || sourced=0
    [[ -t 1 ]] && piped=0 || piped=1 # detect if output is piped
    if [[ $piped -eq 0 ]]; then
        col_reset="\033[0m"
        col_red="\033[1;31m"
        col_grn="\033[1;32m"
        col_ylw="\033[1;33m"
    else
        col_reset=""
        col_red=""
        col_grn=""
        col_ylw=""
    fi

    [[ $(echo -e '\xe2\x82\xac') == '‚Ç¨' ]] && unicode=1 || unicode=0 # detect if unicode is supported
    if [[ $unicode -gt 0 ]]; then
        char_succ="‚úî"
        char_fail="‚úñ"
        char_alrt="‚û®"
        char_wait="‚Ä¶"
        info_icon="üîé"
        config_icon="üñåÔ∏è"
        clean_icon="üßπ"
        require_icon="üìé"
    else
        char_succ="OK "
        char_fail="!! "
        char_alrt="?? "
        char_wait="..."
        info_icon="(i)"
        config_icon="[c]"
        clean_icon="[c]"
        require_icon="[r]"
    fi
    error_prefix="${col_red}>${col_reset}"

    readonly nbcols=$(tput cols 2>/dev/null || echo 80)
    readonly wprogress=$((nbcols - 5))
}

out() { ((quiet)) && true || printf '%b\n' "$*"; }
debug() { if ((verbose)); then out "${col_ylw}# $* ${col_reset}" >&2; else true; fi; }
die() {
    out "${col_red}${char_fail} $script_basename${col_reset}: $*" >&2
    tput bel
    safe_exit
}
alert() { out "${col_red}${char_alrt}${col_reset}: $*" >&2; } # print error and continue
success() { out "${col_grn}${char_succ}${col_reset}  $*"; }
announce() {
    out "${col_grn}${char_wait}${col_reset}  $*"
    sleep 1
}

progress() {
    ((quiet)) || (
        if flag_set ${piped:-0}; then
            out "$*" >&2
        else
            printf "... %-${wprogress}b\r" "$*                                             " >&2
        fi
    )
}

log_to_file() { [[ -n ${log_file:-} ]] && echo "$(date '+%H:%M:%S') | $*" >>"$log_file"; }

lower_case() { echo "$*" | awk '{print tolower($0)}'; }
upper_case() { echo "$*" | awk '{print toupper($0)}'; }

slugify() {
    # shellcheck disable=SC2020
    echo "${1,,}" | xargs | tr '√†√°√¢√§√¶√£√•ƒÅ√ßƒáƒç√®√©√™√´ƒìƒóƒô√Æ√Ø√≠√≠ƒ´ƒØ√¨≈Ç√±≈Ñ√¥√∂√≤√≥≈ì√∏≈ç√µ√ü≈õ≈°√ª√º√π√∫≈´√ø≈æ≈∫≈º' 'aaaaaaaaccceeeeeeeiiiiiiilnnoooooooosssuuuuuyzzz' |
        awk '{
    gsub(/https?/,"",$0); gsub(/[\[\]@#$%^&*;,.:()<>!?\/+=_]/," ",$0);
    gsub(/^  */,"",$0); gsub(/  *$/,"",$0); gsub(/  */,"-",$0); gsub(/[^a-z0-9\-]/,"");
    print;
    }' | cut -c1-50
}

confirm() {
    # $1 = question
    flag_set $force && return 0
    local REPLY=N
    echo " "
    echo " "
    read -r -p "$1 [y/N] " -n 1 REPLY
    echo " "
    [[ $REPLY =~ ^[Yy]$ ]]
}

ask() {
    # $1 = variable name
    # $2 = question
    # $3 = default value
    # not using read -i because that doesn't work on MacOS
    local ANSWER
    read -r -p "$2 ($3) > " ANSWER
    if [[ -z "$ANSWER" ]]; then
        eval "$1=\"$3\""
    else
        eval "$1=\"$ANSWER\""
    fi
}

trap "die \"ERROR \$? after \$SECONDS seconds \n\
\${error_prefix} last command : '\$BASH_COMMAND' \" \
\$(< \$script_install_path awk -v lineno=\$LINENO \
'NR == lineno {print \"\${error_prefix} from line \" lineno \" : \" \$0}')" INT TERM EXIT
# cf https://askubuntu.com/questions/513932/what-is-the-bash-command-variable-good-for

safe_exit() {
    [[ -n "${tmp_file:-}" ]] && [[ -f "$tmp_file" ]] && rm "$tmp_file"
    trap - INT TERM EXIT
    debug "$script_basename finished after $SECONDS seconds"
    exit 0
}

flag_set() { [[ "$1" -gt 0 ]]; }

show_usage() {
    out "Program: ${col_grn}$script_basename $script_version${col_reset} by ${col_ylw}$script_author${col_reset}"
    out "Updated: ${col_grn}$script_modified${col_reset}"
    out "Description: A bootstrapping script"
    echo -n "Usage: $script_basename"
    list_options |
        awk '
  BEGIN { FS="|"; OFS=" "; oneline="" ; fulltext="Flags, options and parameters:"}
  $1 ~ /flag/  {
    fulltext = fulltext sprintf("\n    -%1s|--%-12s: [flag] %s [default: off]",$2,$3,$4) ;
    oneline  = oneline " [-" $2 "]"
    }
  $1 ~ /option/  {
    fulltext = fulltext sprintf("\n    -%1s|--%-12s: [option] %s",$2,$3 " <?>",$4) ;
    if($5!=""){fulltext = fulltext "  [default: " $5 "]"; }
    oneline  = oneline " [-" $2 " <" $3 ">]"
    }
  $1 ~ /list/  {
    fulltext = fulltext sprintf("\n    -%1s|--%-12s: [list] %s (array)",$2,$3 " <?>",$4) ;
    fulltext = fulltext "  [default empty]";
    oneline  = oneline " [-" $2 " <" $3 ">]"
    }
  $1 ~ /secret/  {
    fulltext = fulltext sprintf("\n    -%1s|--%s <%s>: [secret] %s",$2,$3,"?",$4) ;
      oneline  = oneline " [-" $2 " <" $3 ">]"
    }
  $1 ~ /param/ {
    if($2 == "1"){
          fulltext = fulltext sprintf("\n    %-17s: [parameter] %s","<"$3">",$4);
          oneline  = oneline " <" $3 ">"
     }
     if($2 == "?"){
          fulltext = fulltext sprintf("\n    %-17s: [parameter] %s (optional)","<"$3">",$4);
          oneline  = oneline " <" $3 "?>"
     }
     if($2 == "n"){
          fulltext = fulltext sprintf("\n    %-17s: [parameters] %s (1 or more)","<"$3">",$4);
          oneline  = oneline " <" $3 " ‚Ä¶>"
     }
    }
    END {print oneline; print fulltext}
  '
}

check_last_version() {
    (
        # shellcheck disable=SC2164
        pushd "$script_install_folder" &>/dev/null
        local remote
        remote="$(git remote -v | grep fetch | awk 'NR == 1 {print $2}')"
        progress "Check for latest version - $remote"
        git remote update &>/dev/null
        if [[ $(git rev-list --count "HEAD...HEAD@{upstream}" 2>/dev/null) -gt 0 ]]; then
            out "There is a more recent update of this script - run <<$script_prefix update>> to update"
        fi
        # shellcheck disable=SC2164
        popd &>/dev/null
    )
}

update_script_to_latest() {
    # run in background to avoid problems with modifying a running interpreted script
    (
        sleep 1
        cd "$script_install_folder" && git pull
    ) &
}

show_tips() {
    ((sourced)) && return 0
    # shellcheck disable=SC2016
    grep <"${BASH_SOURCE[0]}" -v '$0' |
        awk \
            -v green="$col_grn" \
            -v yellow="$col_ylw" \
            -v reset="$col_reset" \
            '
      /TIP: /  {$1=""; gsub(/¬´/,green); gsub(/¬ª/,reset); print "*" $0}
      /TIP:> / {$1=""; print " " yellow $0 reset}
      ' |
        awk \
            -v script_basename="$script_basename" \
            -v script_prefix="$script_prefix" \
            '{
      gsub(/\$script_basename/,script_basename);
      gsub(/\$script_prefix/,script_prefix);
      print ;
      }'
}

check_script_settings() {
    if [[ -n $(filter_option_type flag) ]]; then
        out "## ${col_grn}boolean flags${col_reset}:"
        filter_option_type flag |
            while read -r name; do
                if ((piped)); then
                    eval "echo \"$name=\$${name:-}\""
                else
                    eval "echo -n \"$name=\$${name:-}  \""
                fi
            done
        out " "
        out " "
    fi

    if [[ -n $(filter_option_type option) ]]; then
        out "## ${col_grn}option defaults${col_reset}:"
        filter_option_type option |
            while read -r name; do
                if ((piped)); then
                    eval "echo \"$name=\$${name:-}\""
                else
                    eval "echo -n \"$name=\$${name:-}  \""
                fi
            done
        out " "
        out " "
    fi

    if [[ -n $(filter_option_type list) ]]; then
        out "## ${col_grn}list options${col_reset}:"
        filter_option_type list |
            while read -r name; do
                if ((piped)); then
                    eval "echo \"$name=(\${${name}[@]})\""
                else
                    eval "echo -n \"$name=(\${${name}[@]})  \""
                fi
            done
        out " "
        out " "
    fi

    if [[ -n $(filter_option_type param) ]]; then
        if ((piped)); then
            debug "Skip parameters for .env files"
        else
            out "## ${col_grn}parameters${col_reset}:"
            filter_option_type param |
                while read -r name; do
                    # shellcheck disable=SC2015
                    ((piped)) && eval "echo \"$name=\\\"\${$name:-}\\\"\"" || eval "echo -n \"$name=\\\"\${$name:-}\\\"  \""
                done
            echo " "
        fi
    fi
}

filter_option_type() {
    list_options | grep "$1|" | cut -d'|' -f3 | sort | grep -v '^\s*$'
}

init_options() {
    local init_command
    init_command=$(list_options |
        grep -v "verbose|" |
        awk '
    BEGIN { FS="|"; OFS=" ";}
    $1 ~ /flag/   && $5 == "" {print $3 "=0; "}
    $1 ~ /flag/   && $5 != "" {print $3 "=\"" $5 "\"; "}
    $1 ~ /option/ && $5 == "" {print $3 "=\"\"; "}
    $1 ~ /option/ && $5 != "" {print $3 "=\"" $5 "\"; "}
    $1 ~ /list/ {print $3 "=(); "}
    $1 ~ /secret/ {print $3 "=\"\"; "}
    ')
    if [[ -n "$init_command" ]]; then
        eval "$init_command"
    fi
}

expects_single_params() { list_options | grep 'param|1|' >/dev/null; }
expects_optional_params() { list_options | grep 'param|?|' >/dev/null; }
expects_multi_param() { list_options | grep 'param|n|' >/dev/null; }

parse_options() {
    if [[ $# -eq 0 ]]; then
        show_usage >&2
        safe_exit
    fi

    ## first process all the -x --xxxx flags and options
    while true; do
        # flag <flag> is saved as $flag = 0/1
        # option <option> is saved as $option
        if [[ $# -eq 0 ]]; then
            ## all parameters processed
            break
        fi
        if [[ ! $1 == -?* ]]; then
            ## all flags/options processed
            break
        fi
        local save_option
        save_option=$(list_options |
            awk -v opt="$1" '
        BEGIN { FS="|"; OFS=" ";}
        $1 ~ /flag/   &&  "-"$2 == opt {print $3"=1"}
        $1 ~ /flag/   && "--"$3 == opt {print $3"=1"}
        $1 ~ /option/ &&  "-"$2 == opt {print $3"=$2; shift"}
        $1 ~ /option/ && "--"$3 == opt {print $3"=$2; shift"}
        $1 ~ /list/ &&  "-"$2 == opt {print $3"+=($2); shift"}
        $1 ~ /list/ && "--"$3 == opt {print $3"=($2); shift"}
        $1 ~ /secret/ &&  "-"$2 == opt {print $3"=$2; shift #noshow"}
        $1 ~ /secret/ && "--"$3 == opt {print $3"=$2; shift #noshow"}
        ')
        if [[ -n "$save_option" ]]; then
            if echo "$save_option" | grep shift >>/dev/null; then
                local save_var
                save_var=$(echo "$save_option" | cut -d= -f1)
                debug "$config_icon parameter: ${save_var}=$2"
            else
                debug "$config_icon flag: $save_option"
            fi
            eval "$save_option"
        else
            die "cannot interpret option [$1]"
        fi
        shift
    done

    ((help)) && (
        show_usage
        check_last_version
        out "                                  "
        echo "### TIPS & EXAMPLES"
        show_tips

    ) && safe_exit

    ## then run through the given parameters
    if expects_single_params; then
        single_params=$(list_options | grep 'param|1|' | cut -d'|' -f3)
        list_singles=$(echo "$single_params" | xargs)
        single_count=$(echo "$single_params" | count_words)
        debug "$config_icon Expect : $single_count single parameter(s): $list_singles"
        [[ $# -eq 0 ]] && die "need the parameter(s) [$list_singles]"

        for param in $single_params; do
            [[ $# -eq 0 ]] && die "need parameter [$param]"
            [[ -z "$1" ]] && die "need parameter [$param]"
            debug "$config_icon Assign : $param=$1"
            eval "$param=\"$1\""
            shift
        done
    else
        debug "$config_icon No single params to process"
        single_params=""
        single_count=0
    fi

    if expects_optional_params; then
        optional_params=$(list_options | grep 'param|?|' | cut -d'|' -f3)
        optional_count=$(echo "$optional_params" | count_words)
        debug "$config_icon Expect : $optional_count optional parameter(s): $(echo "$optional_params" | xargs)"

        for param in $optional_params; do
            debug "$config_icon Assign : $param=${1:-}"
            eval "$param=\"${1:-}\""
            shift
        done
    else
        debug "$config_icon No optional params to process"
        optional_params=""
        optional_count=0
    fi

    if expects_multi_param; then
        #debug "Process: multi param"
        multi_count=$(list_options | grep -c 'param|n|')
        multi_param=$(list_options | grep 'param|n|' | cut -d'|' -f3)
        debug "$config_icon Expect : $multi_count multi parameter: $multi_param"
        ((multi_count > 1)) && die "cannot have >1 'multi' parameter: [$multi_param]"
        ((multi_count > 0)) && [[ $# -eq 0 ]] && die "need the (multi) parameter [$multi_param]"
        # save the rest of the params in the multi param
        if [[ -n "$*" ]]; then
            debug "$config_icon Assign : $multi_param=$*"
            eval "$multi_param=( $* )"
        fi
    else
        multi_count=0
        multi_param=""
        [[ $# -gt 0 ]] && die "cannot interpret extra parameters"
    fi
}

require_binary() {
    binary="$1"
    path_binary=$(which "$binary" 2>/dev/null)
    [[ -n "$path_binary" ]] && debug "Ô∏è$require_icon required [$binary] -> $path_binary" && return 0
    #
    words=$(echo "${2:-}" | wc -l)
    case $words in
    0) install_instructions="$install_package $1" ;;
    1) install_instructions="$install_package $2" ;;
    *) install_instructions="$2" ;;
    esac
    alert "$script_basename needs [$binary] but it cannot be found"
    alert "1) install package  : $install_instructions"
    alert "2) check path       : export PATH=\"[path of your binary]:\$PATH\""
    die "Missing program/script [$binary]"
}

folder_prep() {
    if [[ -n "$1" ]]; then
        local folder="$1"
        local max_days=${2:-365}
        if [[ -d "$folder" ]]; then
            debug "$clean_icon Create folder : [$folder]"
            mkdir -p "$folder"
        else
            debug "$clean_icon Cleanup folder: [$folder] - delete files older than $max_days day(s)"
            find "$folder" -mtime "+$max_days" -type f -exec rm {} \;
        fi
    fi
}

count_words() { wc -w | awk '{ gsub(/ /,""); print}'; }

recursive_readlink() {
    [[ ! -L "$1" ]] && echo "$1" && return 0
    local file_folder
    local link_folder
    local link_name
    file_folder="$(dirname "$1")"
    # resolve relative to absolute path
    [[ "$file_folder" != /* ]] && link_folder="$(cd -P "$file_folder" &>/dev/null && pwd)"
    local symlink
    symlink=$(readlink "$1")
    link_folder=$(dirname "$symlink")
    link_name=$(basename "$symlink")
    [[ -z "$link_folder" ]] && link_folder="$file_folder"
    [[ "$link_folder" == \.* ]] && link_folder="$(cd -P "$file_folder" && cd -P "$link_folder" &>/dev/null && pwd)"
    debug "$info_icon Symbolic ln: $1 -> [$symlink]"
    recursive_readlink "$link_folder/$link_name"
}

lookup_script_data() {
    readonly script_prefix=$(basename "${BASH_SOURCE[0]}" .sh)
    readonly script_basename=$(basename "${BASH_SOURCE[0]}")
    readonly execution_day=$(date "+%Y-%m-%d")
    #readonly execution_year=$(date "+%Y")

    script_install_path="${BASH_SOURCE[0]}"
    debug "$info_icon Script path: $script_install_path"
    script_install_path=$(recursive_readlink "$script_install_path")
    debug "$info_icon Actual path: $script_install_path"
    readonly script_install_folder="$(dirname "$script_install_path")"
    if [[ -f "$script_install_path" ]]; then
        script_hash=$(hash <"$script_install_path" 8)
        script_lines=$(awk <"$script_install_path" 'END {print NR}')
    else
        # can happen when script is sourced by e.g. bash_unit
        script_hash="?"
        script_lines="?"
    fi

    # get shell/operating system/versions
    shell_brand="sh"
    shell_version="?"
    [[ -n "${ZSH_VERSION:-}" ]] && shell_brand="zsh" && shell_version="$ZSH_VERSION"
    [[ -n "${BASH_VERSION:-}" ]] && shell_brand="bash" && shell_version="$BASH_VERSION"
    [[ -n "${FISH_VERSION:-}" ]] && shell_brand="fish" && shell_version="$FISH_VERSION"
    [[ -n "${KSH_VERSION:-}" ]] && shell_brand="ksh" && shell_version="$KSH_VERSION"
    debug "$info_icon Shell type : $shell_brand - version $shell_version"

    readonly os_kernel=$(uname -s)
    os_version=$(uname -r)
    os_machine=$(uname -m)
    install_package=""
    case "$os_kernel" in
    CYGWIN* | MSYS* | MINGW*)
        os_name="Windows"
        ;;
    Darwin)
        os_name=$(sw_vers -productName)       # macOS
        os_version=$(sw_vers -productVersion) # 11.1
        install_package="brew install"
        ;;
    Linux | GNU*)
        if [[ $(which lsb_release) ]]; then
            # 'normal' Linux distributions
            os_name=$(lsb_release -i)    # Ubuntu
            os_version=$(lsb_release -r) # 20.04
        else
            # Synology, QNAP,
            os_name="Linux"
        fi
        [[ -x /bin/apt-cyg ]] && install_package="apt-cyg install"     # Cygwin
        [[ -x /bin/dpkg ]] && install_package="dpkg -i"                # Synology
        [[ -x /opt/bin/ipkg ]] && install_package="ipkg install"       # Synology
        [[ -x /usr/sbin/pkg ]] && install_package="pkg install"        # BSD
        [[ -x /usr/bin/pacman ]] && install_package="pacman -S"        # Arch Linux
        [[ -x /usr/bin/zypper ]] && install_package="zypper install"   # Suse Linux
        [[ -x /usr/bin/emerge ]] && install_package="emerge"           # Gentoo
        [[ -x /usr/bin/yum ]] && install_package="yum install"         # RedHat RHEL/CentOS/Fedora
        [[ -x /usr/bin/apk ]] && install_package="apk add"             # Alpine
        [[ -x /usr/bin/apt-get ]] && install_package="apt-get install" # Debian
        [[ -x /usr/bin/apt ]] && install_package="apt install"         # Ubuntu
        ;;

    esac
    debug "$info_icon System OS  : $os_name ($os_kernel) $os_version on $os_machine"
    debug "$info_icon Package mgt: $install_package"

    # get last modified date of this script
    script_modified="??"
    [[ "$os_kernel" == "Linux" ]] && script_modified=$(stat -c %y "$script_install_path" 2>/dev/null | cut -c1-16) # generic linux
    [[ "$os_kernel" == "Darwin" ]] && script_modified=$(stat -f "%Sm" "$script_install_path" 2>/dev/null)          # for MacOS

    debug "$info_icon Last modif : $script_modified"
    debug "$info_icon Script ID  : $script_lines lines / md5: $script_hash"
    debug "$info_icon Creation   : $script_created"
    debug "$info_icon Running as : $USER@$HOSTNAME"

    # if run inside a git repo, detect for which remote repo it is
    if git status &>/dev/null; then
        readonly git_repo_remote=$(git remote -v | awk '/(fetch)/ {print $2}')
        debug "$info_icon git remote : $git_repo_remote"
        readonly git_repo_root=$(git rev-parse --show-toplevel)
        debug "$info_icon git folder : $git_repo_root"
    else
        readonly git_repo_root=""
        readonly git_repo_remote=""
    fi

    # get script version from VERSION.md file - which is automatically updated by pforret/setver
    [[ -f "$script_install_folder/VERSION.md" ]] && script_version=$(cat "$script_install_folder/VERSION.md")
    # get script version from git tag file - which is automatically updated by pforret/setver
    [[ -n "$git_repo_root" ]] && [[ -n "$(git tag &>/dev/null)" ]] && script_version=$(git tag --sort=version:refname | tail -1)
}

prep_log_and_temp_dir() {
    tmp_file=""
    log_file=""
    if [[ -n "${tmp_dir:-}" ]]; then
        folder_prep "$tmp_dir" 1
        tmp_file=$(mktemp "$tmp_dir/$execution_day.XXXXXX")
        debug "$config_icon tmp_file: $tmp_file"
        # you can use this temporary file in your program
        # it will be deleted automatically if the program ends without problems
    fi
    if [[ -n "${log_dir:-}" ]]; then
        folder_prep "$log_dir" 30
        log_file="$log_dir/$script_prefix.$execution_day.log"
        debug "$config_icon log_file: $log_file"
    fi
}

import_env_if_any() {
    env_files=("$script_install_folder/.env" "$script_install_folder/$script_prefix.env" "./.env" "./$script_prefix.env")

    for env_file in "${env_files[@]}"; do
        if [[ -f "$env_file" ]]; then
            debug "$config_icon Read config from [$env_file]"
            # shellcheck disable=SC1090
            source "$env_file"
        fi
    done
}

initialise_output  # output settings
lookup_script_data # find installation folder

[[ $run_as_root == 1 ]] && [[ $UID -ne 0 ]] && die "user is $USER, MUST be root to run [$script_basename]"
[[ $run_as_root == -1 ]] && [[ $UID -eq 0 ]] && die "user is $USER, CANNOT be root to run [$script_basename]"

init_options      # set default values for flags & options
import_env_if_any # overwrite with .env if any

if [[ $sourced -eq 0 ]]; then
    parse_options "$@"    # overwrite with specified options if any
    prep_log_and_temp_dir # clean up debug and temp folder
    main                  # run main program
    safe_exit             # exit and clean up
else
    # just disable the trap, don't execute main
    trap - INT TERM EXIT
fi

# vim: set expandtab:ts=4:sw=4
